package Magician
    import Entity
    import EntityManagement
    import Terrain
    import TerrainUtils
    import PlayerData    
    import PrintingHelper
    import ExtensionFunctions
    import Arena
    import Vectors
    import Physics
    import Collisions
    
    constant int MAGICIAN_ID = 'magi'
    constant real COLLISION_SIZE = 32.
    constant int VOID_ID = 1097101927
    
    public class Magician extends UnitEntity
        
        real hp
        real dmgRecieved

        
        construct(vec3 pos, real facing, player p) 
            super(pos, COLLISION_SIZE, CreateUnit( p, MAGICIAN_ID , pos.x, pos.y, facing ), p )
            collisionEntities.add(this)
            
        
        override function onCollision(Entity e)
            if e.owner != owner
                vec2 pos1 = position.toVec2() 
                vec2 pos2 = e.position.toVec2()
                vec2 delta = pos1 - pos2
                real d = delta.length()
                vec2 mtd = delta * (((radius + e.radius)-d)/d)
                if e.isStatic
                    print("magi on obelisk")
                    

				    
				    print("delta: " + delta.toString())		
		            
		            print("length: " +delta.length().toString())
		            
		            
		            setNewPos( position + (mtd.toVec3()*1.001) )
		            print(velocity.lengthSquared().toString())
		            if velocity.lengthSquared() > 1.
						print("vel")
		            	velocity += mtd.toVec3()

					print("4...")
				else
					if e instanceof Magician
						print("meh")
					            
        override function inAir()
        	velocity += gravity
        	super.inAir()
        	
        override function onGround()
        	super.onGround()

        	if GetTerrainType(position.x, position.y) == VOID_ID
                actor.setHP( actor.getHP() - 10.2 )
                if actor.getHP() <= .405
                    active = false
                    AddSpecialEffect("Abilities\\Spells\\Other\\HowlOfTerror\\HowlCaster.mdl", position.x, position.y)
        	if velocity.z < -1
                velocity = vec3(velocity.x, velocity.y, -velocity.z/2)
        	velocity *= 0.985
        	
        override function outOfBounds(Side side)
            switch side
            	case Side.LEFT
	                print("unter minx")
	                position.x = currentArena.minX + radius // Place ball against edge
	                velocity.x = -velocity.x // Reverse direction and account for friction
	                velocity.y = velocity.y
            	case Side.RIGHT // Right Wall
	                print("ueber maxX")
	                position.x = currentArena.maxX - radius		// Place ball against edge
	                velocity.x = -velocity.x // Reverse direction and account for friction
	                velocity.y = velocity.y
            	case Side.TOP			// Top Wall
	                print("unter miny")
	                position.y = currentArena.minY + radius					// Place ball against edge
	                velocity.x = velocity.x  // Reverse direction and account for friction
	                velocity.y = -velocity.y
            	case Side.BOTTOM // Bottom Wall
	                print("ueber maxY")
	                position.y = currentArena.maxY - radius			// Place ball against edge
	                velocity.x = velocity.x     // Reverse direction and account for friction
	                velocity.y = -velocity.y 


            
    public function initMagicians() //Do Shit
        print( "initializing Magicians.." )
        real distance = MAX_TILES*128. - 64.
        PlayerData pd = PlayerData.first
        int i = 0
        while pd != null
            real angle = 180 + (360/PlayerData.size) * i
            pd.mainUnit = new Magician( vec2(0,0).polarOffset(angle*bj_DEGTORAD, distance).withZ(500), angle - 180, pd.p )
            i++
            pd = pd.next
        print( "initializing Magicians..done!" )
    

endpackage 