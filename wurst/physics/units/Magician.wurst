package Magician
    import Entity
    import EntityManagement
    import Terrain
    import TerrainUtils
    import PlayerData    
    import PrintingHelper
    import ExtensionFunctions
    import Arena
    import Vectors
    import Physics
    import Collisions
    
    constant int MAGICIAN_ID = 'magi'
    constant real COLLISION_SIZE = 32.
    
    public class Magician extends UnitEntity
        
        real hp
        real dmgRecieved

        
        construct(vec3 pos, real facing, player p) 
            super(pos, COLLISION_SIZE, CreateUnit( p, MAGICIAN_ID , pos.x, pos.y, facing ), p )
            collisionEntities.add(this)
            
        override function onCollision(Entity e)
            if e.owner != owner
                if e.isStatic
                    velocity += collisionWithStaticVelocityChange(position.toVec2(), velocity.toVec2(), e.position.toVec2()).toVec3()
                    collideWithStatic(e)
				else if e instanceof DynamicEntity
					collideWithDynamicEntity(e castTo DynamicEntity)
					
            
        override function inAir()
        	velocity += gravity
        	super.inAir()
        	
        override function onGround()
        	super.onGround()
        	if velocity.z < -1
                velocity = vec3(velocity.x, velocity.y, -velocity.z/2)
        	velocity *= 0.985
        	velocity = velocity.trim(1.)
        	
        override function outOfBounds(Side side)
            switch side
            	case Side.LEFT
	                print("unter minx")
	                position.x = currentArena.minX + radius // Place ball against edge
	                velocity.x = -velocity.x // Reverse direction and account for friction
	                velocity.y = velocity.y
            	case Side.RIGHT // Right Wall
	                print("ueber maxX")
	                position.x = currentArena.maxX - radius		// Place ball against edge
	                velocity.x = -velocity.x // Reverse direction and account for friction
	                velocity.y = velocity.y
            	case Side.TOP			// Top Wall
	                print("unter miny")
	                position.y = currentArena.minY + radius					// Place ball against edge
	                velocity.x = velocity.x  // Reverse direction and account for friction
	                velocity.y = -velocity.y
            	case Side.BOTTOM // Bottom Wall
	                print("ueber maxY")
	                position.y = currentArena.maxY - radius			// Place ball against edge
	                velocity.x = velocity.x     // Reverse direction and account for friction
	                velocity.y = -velocity.y 
            
            

            
    public function initMagicians() //Do Shit
        print( "initializing Magicians.." )
        real distance = MAX_TILES*128. - 64.
        PlayerData pd = PlayerData.first
        int i = 0
        while pd != null
            real angle = 180 + (360/PlayerData.size) * i
            pd.mainUnit = new Magician( vec2(0,0).polarOffset(angle*bj_DEGTORAD, distance).withZ(500), angle - 180, pd.p )
            i++
            pd = pd.next
        print( "initializing Magicians..done!" )
    

endpackage 